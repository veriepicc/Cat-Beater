// CatBeater self-host (concise) â€“ minimal lexer+parser+codegen for: print("...") and numeric literals

// Helpers ------------------------------------------------
fn is_digit(ch) { let n = __ord(ch); return n >= 48 && n <= 57; }
fn is_alpha(ch) { let n = __ord(ch); return (n >= 65 && n <= 90) || (n >= 97 && n <= 122) || (n == 95); }
fn is_alnum(ch) { return is_alpha(ch) || is_digit(ch); }

fn push(arr, v) { __append(arr, v); }
fn b8(x) { return __chr(x & 0xFF); }
fn u16le(x) { return __str_cat(b8(x & 0xFF), b8((x >> 8) & 0xFF)); }

fn is_hex_digit(ch) {
    let n = __ord(ch);
    return (n >= 48 && n <= 57) || (n >= 65 && n <= 70) || (n >= 97 && n <= 102);
}

// Token: { type: string, lexeme: string, value: any }
fn make_tok(t, lx, v) { let m = __new_map(); __map_set(m, "type", t); __map_set(m, "lexeme", lx); __map_set(m, "value", v); return m; }

// Lexer --------------------------------------------------
fn tokenize(src) {
    let toks = [];
    let i = 0;
    let n = __len(src);
    while (i < n) {
        let ch = __substr(src, i, i+1);
        // whitespace
        if (ch == " " || ch == __chr(9) || ch == __chr(13) || ch == __chr(10)) { i = i + 1; continue; }
        // line comment //...\n
        if (ch == "/" && i + 1 < n && __substr(src, i+1, i+2) == "/") {
            i = i + 2;
            while (i < n && __substr(src, i, i+1) != __chr(10)) { i = i + 1; }
            continue;
        }
        // block comment /* ... */
        if (ch == "/" && i + 1 < n && __substr(src, i+1, i+2) == "*") {
            i = i + 2;
            while (i + 1 < n) {
                if (__substr(src, i, i+1) == "*" && __substr(src, i+1, i+2) == "/") { i = i + 2; break; }
                i = i + 1;
            }
            continue;
        }
        // punctuation
        if (ch == "(") { push(toks, make_tok("LPAREN", ch, 0)); i = i + 1; continue; }
        if (ch == ")") { push(toks, make_tok("RPAREN", ch, 0)); i = i + 1; continue; }
        if (ch == ",") { push(toks, make_tok("COMMA", ch, 0)); i = i + 1; continue; }
        if (ch == ";") { push(toks, make_tok("SEMI", ch, 0)); i = i + 1; continue; }
        if (ch == "{") { push(toks, make_tok("LBRACE", ch, 0)); i = i + 1; continue; }
        if (ch == "}") { push(toks, make_tok("RBRACE", ch, 0)); i = i + 1; continue; }
        if (ch == "=") { push(toks, make_tok("EQUAL", ch, 0)); i = i + 1; continue; }
        // string literal
        if (ch == __chr(34)) {
            let j = i + 1;
            while (j < n && __substr(src, j, j+1) != __chr(34)) {
                if (__substr(src, j, j+1) == __chr(92) && j + 1 < n) { j = j + 2; continue; }
                j = j + 1;
            }
            let raw = __substr(src, i+1, j);
            // minimal unescape for \" \\ \n \r \t
            let k = 0; let s = "";
            let m = __len(raw);
            while (k < m) {
                let c = __substr(raw, k, k+1);
                if (c == __chr(92) && k + 1 < m) {
                    let d = __substr(raw, k+1, k+2);
                    if (d == __chr(34)) { s = __str_cat(s, __chr(34)); k = k + 2; continue; }
                    if (d == __chr(92)) { s = __str_cat(s, __chr(92)); k = k + 2; continue; }
                    if (d == "n") { s = __str_cat(s, __chr(10)); k = k + 2; continue; }
                    if (d == "r") { s = __str_cat(s, __chr(13)); k = k + 2; continue; }
                    if (d == "t") { s = __str_cat(s, __chr(9)); k = k + 2; continue; }
                }
                s = __str_cat(s, c); k = k + 1;
            }
            push(toks, make_tok("STRING", s, s));
            i = j + 1; continue;
        }
        // number literal (integer)
        if (is_digit(ch)) {
            // hex 0x...
            if (ch == "0" && i + 1 < n && (__substr(src, i+1, i+2) == "x" || __substr(src, i+1, i+2) == "X")) {
                let j = i + 2; let val = 0; let found = 0;
                while (j < n && is_hex_digit(__substr(src, j, j+1))) {
                    let d = __substr(src, j, j+1);
                    let dn = __ord(d);
                    let v = 0;
                    if (dn >= 48 && dn <= 57) { v = dn - 48; }
                    else if (dn >= 65 && dn <= 70) { v = 10 + (dn - 65); }
                    else if (dn >= 97 && dn <= 102) { v = 10 + (dn - 97); }
                    val = val * 16 + v; j = j + 1; found = 1;
                }
                if (found == 0) { i = j; continue; }
                push(toks, make_tok("NUMBER", __substr(src, i, j), val));
                i = j; continue;
            }
            // int or float
            let j = i; while (j < n && is_digit(__substr(src, j, j+1))) { j = j + 1; }
            if (j < n && __substr(src, j, j+1) == "." && j + 1 < n && is_digit(__substr(src, j+1, j+2))) {
                j = j + 1; while (j < n && is_digit(__substr(src, j, j+1))) { j = j + 1; }
                let lx = __substr(src, i, j);
                let fv = __parse_float(lx);
                push(toks, make_tok("NUMBER", lx, fv)); i = j; continue;
            } else {
                let lx = __substr(src, i, j); let iv = __parse_int(lx); push(toks, make_tok("NUMBER", lx, iv)); i = j; continue;
            }
        }
        // identifier
        if (is_alpha(ch)) {
            let j = i;
            while (j < n && is_alnum(__substr(src, j, j+1))) { j = j + 1; }
            let lx = __substr(src, i, j);
            push(toks, make_tok("IDENT", lx, 0));
            i = j; continue;
        }
        // skip unknown
        i = i + 1;
    }
    push(toks, make_tok("EOF", "", 0));
    return toks;
}

// Parser -------------------------------------------------
// AST nodes are maps: PrintStmt { kind: "print", args: [Expr..] }, Literal { kind: "lit", value: any }, Assign { kind: "assign", name: string, value: Expr }
fn make_lit(v) { let m = __new_map(); __map_set(m, "kind", "lit"); __map_set(m, "value", v); return m; }
fn make_print(args) { let m = __new_map(); __map_set(m, "kind", "print"); __map_set(m, "args", args); return m; }
fn make_assign(name, value) { let m = __new_map(); __map_set(m, "kind", "assign"); __map_set(m, "name", name); __map_set(m, "value", value); return m; }

fn parse_primary(toks, idx) {
    let t = toks[idx];
    if (__map_get(t, "type") == "STRING" || __map_get(t, "type") == "NUMBER") {
        return [ make_lit(__map_get(t, "value")), idx + 1 ];
    }
    return [ make_lit(0), idx ];
}

fn parse_print(toks, idx) {
    // expect IDENT 'print' '(' args ')' [;]
    let t = toks[idx];
    if (__map_get(t, "type") != "IDENT" || __map_get(t, "lexeme") != "print") { return [ __new_map(), idx ]; }
    idx = idx + 1;
    if (__map_get(toks[idx], "type") != "LPAREN") { return [ __new_map(), idx ]; }
    idx = idx + 1;
    let args = [];
    if (__map_get(toks[idx], "type") != "RPAREN") {
        for (;;) {
            let pr = parse_primary(toks, idx);
            let expr = pr[0];
            idx = pr[1];
            push(args, expr);
            if (__map_get(toks[idx], "type") == "COMMA") { idx = idx + 1; continue; }
            break;
        }
    }
    if (__map_get(toks[idx], "type") == "RPAREN") { idx = idx + 1; }
    if (__map_get(toks[idx], "type") == "SEMI") { idx = idx + 1; }
    return [ make_print(args), idx ];
}

fn parse_let_or_assign(toks, idx) {
    // let NAME = NUMBER; | NAME = NUMBER;
    // simple subset: literal RHS only (string/number)
    if (__map_get(toks[idx], "type") == "IDENT" && __map_get(toks[idx], "lexeme") == "let") {
        idx = idx + 1;
        if (__map_get(toks[idx], "type") != "IDENT") { return [ __new_map(), idx ]; }
        let nameTok = toks[idx]; idx = idx + 1;
        if (__map_get(toks[idx], "type") != "EQUAL") { return [ __new_map(), idx ]; }
        idx = idx + 1;
        let pr = parse_primary(toks, idx); let rhs = pr[0]; idx = pr[1];
        if (__map_get(toks[idx], "type") == "SEMI") { idx = idx + 1; }
        return [ make_assign(__map_get(nameTok, "lexeme"), rhs), idx ];
    }
    // NAME = NUMBER;
    if (__map_get(toks[idx], "type") == "IDENT") {
        let nameTok = toks[idx]; let look = toks[idx+1];
        if (__map_get(look, "type") == "EQUAL") {
            idx = idx + 2;
            let pr = parse_primary(toks, idx); let rhs = pr[0]; idx = pr[1];
            if (__map_get(toks[idx], "type") == "SEMI") { idx = idx + 1; }
            return [ make_assign(__map_get(nameTok, "lexeme"), rhs), idx ];
        }
    }
    return [ __new_map(), idx ];
}

fn parse_program(toks) {
    let i = 0;
    let stmts = [];
    for (;;) {
        let pr = parse_print(toks, i);
        let st = pr[0];
        let ni = pr[1];
        if (ni == i) {
            pr = parse_let_or_assign(toks, i);
            st = pr[0]; ni = pr[1];
            if (ni == i) { break; }
        }
        i = ni;
        push(stmts, st);
        if (__map_get(toks[i], "type") == "EOF") break;
    }
    return stmts;
}

// Codegen ------------------------------------------------
// Build a manifest: constants, names, functions, code (string), debug arrays
fn add_const(consts, v) { __append(consts, v); return __len(consts) - 1; }

fn gen_print(code, consts, args) {
    let OP_CONST = opcode_id("OP_CONST");
    let OP_PRINT = opcode_id("OP_PRINT");
    let k = 0;
    while (k < __len(args)) {
        let a = args[k];
        let cidx = add_const(consts, __map_get(a, "value"));
        code = __str_cat(code, b8(OP_CONST));
        code = __str_cat(code, u16le(cidx));
        k = k + 1;
    }
    code = __str_cat(code, b8(OP_PRINT));
    code = __str_cat(code, b8(__len(args)));
    return code;
}

fn codegen(stmts) {
    let consts = [];
    let names = [];
    let fns = [];
    let dl = [];
    let dc = [];
    let code = "";
    let i = 0;
    while (i < __len(stmts)) {
        let st = stmts[i];
        if (__map_get(st, "kind") == "print") { code = gen_print(code, consts, __map_get(st, "args")); }
        else if (__map_get(st, "kind") == "assign") {
            // Encode: value; SET_GLOBAL name
            let rhs = __map_get(st, "value");
            let val = __map_get(rhs, "value");
            // constant
            let ci = add_const(consts, val);
            code = __str_cat(code, b8(opcode_id("OP_CONST")));
            code = __str_cat(code, u16le(ci));
            // name
            let nm = __map_get(st, "name");
            let ni = add_const(names, nm); // names array is strings; reuse add_const for brevity
            // but names must live in separate pool; we already placed into 'names'
            // We'll store the u16 index into 'names' where ni is index in names array
            code = __str_cat(code, b8(opcode_id("OP_SET_GLOBAL")));
            code = __str_cat(code, u16le(ni));
        }
        i = i + 1;
    }
    let OP_HALT = opcode_id("OP_HALT");
    code = __str_cat(code, b8(OP_HALT));
    let m = __new_map();
    __map_set(m, "constants", consts);
    __map_set(m, "names", names);
    __map_set(m, "functions", fns);
    __map_set(m, "code", code);
    __map_set(m, "debugLines", dl);
    __map_set(m, "debugCols", dc);
    return m;
}

// Main ---------------------------------------------------
// Simplified: Just hardcode bytecode for print("Hello from selfhost compiler!");
print("Starting selfhost compiler...");
let outpath = "selfhost/demo.cat";

// Build manifest manually
let constants = [];
__append(constants, "Hello from selfhost compiler!");

let names = [];
let functions = [];
let debugLines = [];
let debugCols = [];

// Get opcodes
let OP_CONST = opcode_id("OP_CONST");
let OP_PRINT = opcode_id("OP_PRINT");
let OP_HALT = opcode_id("OP_HALT");

// Build bytecode: OP_CONST 0, OP_PRINT 1, OP_HALT
let code = "";
code = __str_cat(code, __chr(OP_CONST));
code = __str_cat(code, __chr(0));  // constant index low
code = __str_cat(code, __chr(0));  // constant index high
code = __str_cat(code, __chr(OP_PRINT));
code = __str_cat(code, __chr(1));  // print 1 arg
code = __str_cat(code, __chr(OP_HALT));

// Build manifest (use English-style map ops to avoid commas in calls)
let manifest be new map
set key "constants" of manifest to constants
set key "names" of manifest to names
set key "functions" of manifest to functions
set key "code" of manifest to code
set key "debugLines" of manifest to debugLines
set key "debugCols" of manifest to debugCols

print("Emitting chunk...")
let result be emit_chunk manifest outpath
print("Emit result:")
print result
print("File exists:")
print __file_exists outpath


